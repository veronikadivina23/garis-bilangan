<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Subtract Integer Â· Pengurangan Bilangan Bulat</title>
<style>
  :root{
    --bg: linear-gradient(135deg,#f3eefe 0%, #f0f3ff 100%);
    --card: #fff;
    --purple: #7b5cff;
    --muted: #9b8fcf;
    --green: #00b386;
    --yellow: #ffd24a;
    --radius: 18px;
    --shadow: 0 8px 24px rgba(123,92,255,0.12);
    --gap: 18px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  html,body{height:100%;margin:0;background:var(--bg);color:#2b2350}
  .app{
    max-width:1100px;margin:28px auto;padding:20px;
  }

  header h1{font-size:2.4rem;margin:0;color:var(--purple);letter-spacing:0.2px}
  header h2{font-size:1.1rem;margin:6px 0 16px;color: #4b3f7b;font-weight:600}

  .controls{
    display:flex;gap:12px;align-items:center;margin-bottom:18px;
    flex-wrap:wrap;
  }
  .control{
    background:var(--card);padding:12px 16px;border-radius:14px;box-shadow:var(--shadow);display:flex;align-items:center;gap:10px;
  }
  .control label{font-size:0.9rem;color:#6b5f90}
  input[type=number]{
    width:110px;padding:10px 12px;border-radius:10px;border:2px solid #efe8ff;font-size:1.05rem;text-align:center;outline:none;
  }
  input[type=number]:focus{border-color:var(--purple);box-shadow:0 4px 14px rgba(123,92,255,0.14)}
  .op-btn{
    display:inline-grid;place-items:center;width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg,#efe6ff,#f9f6ff);border:2px solid #e7ddff;font-size:1.8rem;color:var(--purple);
    box-shadow: 0 6px 18px rgba(123,92,255,0.06);
  }
  #hintBtn{width:44px;height:44px;border-radius:999px;border:none;background:var(--purple);color:white;font-size:1.05rem;cursor:pointer}

  .card{
    background:var(--card);padding:22px;border-radius:26px;box-shadow:var(--shadow);min-height:260px;
  }

  .result-panel{
    margin-top:16px;padding:18px;border-radius:14px;background:linear-gradient(180deg,#f4f0ff,#fff);text-align:center;font-weight:700;color:var(--purple);
    font-size:1.25rem;box-shadow:0 6px 16px rgba(123,92,255,0.06)
  }

  /* responsive */
  @media (max-width:640px){
    input[type=number]{width:88px}
    .controls{gap:10px}
  }

  /* small svg helper */
  .svg-wrap{width:100%;height:260px;display:flex;align-items:center;justify-content:center}
  svg{width:100%;height:100%;overflow:visible}

  /* tick labels */
  .tick text{font-size:12px;fill:#6b5f90}
  .marker-label{font-size:13px;fill:#fff;font-weight:700}

  /* dashed move */
  .dash-line{stroke-dasharray:8 6;stroke-linecap:round}
  /* animation classes */
  .animate{
    transition: transform 380ms cubic-bezier(.2,.9,.25,1), cx 380ms ease;
  }
  .pulse {
    animation: pulse 900ms ease;
  }
  @keyframes pulse{
    0%{transform:scale(1);opacity:1}
    60%{transform:scale(1.08);opacity:0.9}
    100%{transform:scale(1);opacity:1}
  }

  /* accessibility helper (visually hidden) */
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
</style>
</head>
<body>
<div class="app" role="application" aria-labelledby="title">
  <header>
    <h1 id="title">Subtract Integer</h1>
    <h2>Pengurangan Bilangan Bulat</h2>
  </header>

  <div class="controls" aria-hidden="false">
    <div class="control" title="Angka Pertama (titik awal)">
      <label for="inputA">ðŸŒ¸ Angka Pertama</label>
      <input id="inputA" type="number" step="1" value="5" aria-label="Angka pertama" />
    </div>

    <div class="op-btn" aria-hidden="true">âˆ’</div>

    <div class="control" title="Angka Kedua (langkah)">
      <label for="inputB">ðŸ’œ Angka Kedua</label>
      <input id="inputB" type="number" step="1" value="8" aria-label="Angka kedua" />
    </div>

    <button id="hintBtn" title="Contoh / Hint" aria-label="Hint">ðŸ’¡</button>
  </div>

  <section class="card" aria-live="polite" id="visualCard">
    <div class="svg-wrap">
      <svg id="numberlineSVG" viewBox="0 0 1000 260" role="img" aria-label="Garis bilangan interaktif.">
        <!-- SVG content dibuat oleh JavaScript -->
      </svg>
    </div>
  </section>

  <div class="result-panel" aria-live="polite" id="resultText">
    5 - (8) = -3
  </div>

  <p class="sr-only" id="srStatus">Nilai awal: 5. Langkah: 8. Hasil: -3.</p>
</div>

<script>
/* ===========================================================
   Interactive numberline for subtraction
   Rules:
   - Angka pertama: posisi awal.
   - Angka kedua: langkah; positive -> move LEFT from angka pertama.
                  negative -> move RIGHT from angka pertama.
   - Autoscale so that a, result, and zero are visible.
   =========================================================== */

(() => {
  // DOM
  const inputA = document.getElementById('inputA');
  const inputB = document.getElementById('inputB');
  const svg = document.getElementById('numberlineSVG');
  const resultText = document.getElementById('resultText');
  const srStatus = document.getElementById('srStatus');
  const hintBtn = document.getElementById('hintBtn');

  // State and constants
  const margin = {left:80, right:80, top:20, bottom:60};
  let state = { a: parseInt(inputA.value)||0, b: parseInt(inputB.value)||0, result:0, min:-5, max:10 };
  const svgDims = { width: 1000, height: 260 };

  // Utility: debounce
  function debounce(fn, ms=120){
    let t; return (...args)=>{clearTimeout(t); t=setTimeout(()=>fn(...args),ms);}
  }

  // compute result and auto-scale
  function computeState(a,b){
    const result = a - b;
    // compute minimal range containing a, result, 0 with padding
    let points = [a, result, 0];
    let min = Math.min(...points);
    let max = Math.max(...points);
    // padding units (2 units or 10% of range)
    let pad = Math.max(2, Math.ceil((max - min) * 0.15));
    if (min === max){ min -= pad; max += pad; } // avoid zero range
    min = Math.min(min - pad, min - 2);
    max = Math.max(max + pad, max + 2);
    // clamp very large ranges
    const MAX_SPAN = 2000;
    if (max - min > MAX_SPAN){
      // center around median but cap span
      const mid = Math.round((min + max)/2);
      min = mid - MAX_SPAN/2; max = mid + MAX_SPAN/2;
    }
    return {a,b,result,min,max};
  }

  // mapping: value -> x coordinate in SVG
  function computeScale(min, max){
    const innerW = svgDims.width - margin.left - margin.right;
    const pxPerUnit = innerW / (max - min);
    return {min, max, pxPerUnit, innerW};
  }
  function valueToX(v, scale){ return margin.left + (v - scale.min) * scale.pxPerUnit; }

  // Draw helpers
  function clearSvg(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function createElem(tag, attrs={}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for(const k in attrs){
      if(k==='text'){ el.textContent = attrs[k]; continue; }
      el.setAttribute(k, attrs[k]);
    }
    return el;
  }

  // Draw numberline with ticks, markers, dashed move, arrows
  function render({a,b,result,min,max}){
    clearSvg();
    const scale = computeScale(min,max);
    // axis Y position
    const axisY = 120;
    // draw axis line (main)
    const axis = createElem('line',{x1:margin.left,x2:svgDims.width - margin.right,y1:axisY,y2:axisY, stroke:'#e7e0fb','stroke-width':6,'stroke-linecap':'round'});
    svg.appendChild(axis);

    // ticks: decide step
    const span = max - min;
    let step = 1;
    if (span > 40) step = 5;
    if (span > 140) step = 10;
    if (span > 420) step = Math.ceil(span / 60);

    // ticks & labels
    for (let v = Math.ceil(min); v <= Math.floor(max); v += step){
      const x = valueToX(v, scale);
      const tick = createElem('line',{x1:x,y1:axisY-12,x2:x,y2:axisY+12,stroke:'#efe8ff','stroke-width':2});
      svg.appendChild(tick);
      const t = createElem('text',{x:x,y:axisY+32, 'text-anchor':'middle', 'dominant-baseline':'middle'});
      t.textContent = v;
      t.setAttribute('class','tick');
      svg.appendChild(t);
    }

    // zero marker (vertical highlight)
    if (min <= 0 && max >= 0){
      const x0 = valueToX(0, scale);
      const z = createElem('line',{x1:x0,y1:axisY-22,x2:x0,y2:axisY+22,stroke:'#dcd3ff','stroke-width':3});
      svg.appendChild(z);
      const zlbl = createElem('text',{x:x0,y:axisY-40,'text-anchor':'middle'});
      zlbl.textContent = '0';
      zlbl.setAttribute('fill','#8d79c6');
      svg.appendChild(zlbl);
    }

    // marker A (start)
    const xA = valueToX(a, scale);
    const markerAGroup = createElem('g',{});
    const markerACircle = createElem('circle',{cx:xA,cy:axisY, r:14, fill: 'white', stroke: 'var(--purple)', 'stroke-width':4});
    markerACircle.setAttribute('class','markerA');
    const labelA = createElem('text',{x:xA,y:axisY-22,'text-anchor':'middle'});
    labelA.textContent = a;
    labelA.setAttribute('fill','#6b5f90');
    markerAGroup.appendChild(markerACircle);
    markerAGroup.appendChild(labelA);
    svg.appendChild(markerAGroup);

    // calculate final position based on rule: b >= 0 => move left; b < 0 => move right
    // effect: final = a - b (standard math). Movement direction computed accordingly:
    const xFinal = valueToX(result, scale);

    // dashed move line from A to final
    const dash = createElem('line',{
      x1: xA,
      x2: xFinal,
      y1: axisY - 46,
      y2: axisY - 46,
      stroke: (b>=0) ? '#00b386':'#ff9f68',
      'stroke-width':10,
      'class':'dash-line',
      'stroke-linecap':'round'
    });
    // rotate arrowhead depending direction
    svg.appendChild(dash);

    // arrow head
    const arrowDir = (xFinal < xA) ? -1 : 1;
    const arrowX = xFinal + (arrowDir * 10);
    const arrow = createElem('path',{
      d: `M ${arrowX - 8*arrowDir} ${axisY-52} L ${arrowX} ${axisY-42} L ${arrowX - 8*arrowDir} ${axisY-32}`,
      fill: (b>=0)?'#00b386':'#ff9f68'
    });
    svg.appendChild(arrow);

    // result marker (distinct)
    const resGroup = createElem('g',{});
    const resCircle = createElem('rect',{x:xFinal-14,y:axisY-14,width:28,height:28,rx:8,ry:8,fill: 'var(--purple)'});
    resCircle.setAttribute('class','resultMarker');
    const resText = createElem('text',{x:xFinal,y:axisY+6,'text-anchor':'middle'});
    resText.textContent = result;
    resText.setAttribute('class','marker-label');
    resGroup.appendChild(resCircle);
    resGroup.appendChild(resText);
    svg.appendChild(resGroup);

    // small legend / explanation near bottom
    const expl = createElem('text',{x:svgDims.width/2,y:svgDims.height-6,'text-anchor':'middle','fill':'#6b5f90'});
    expl.textContent = `Aturan: Angka Kedua ${b>=0? 'positif â†’ gerak kiri' : 'negatif â†’ gerak kanan'}`;
    svg.appendChild(expl);

    // Add subtle stripe under dashed to show direction steps (a few dotted ticks)
    const steps = Math.min( Math.abs(Math.round(b)), 16); // limit number of small step markers
    if (steps > 0 && Math.abs(xFinal - xA) > 2){
      for (let i=1;i<=steps;i++){
        const tval = a + ( (result - a) * (i/steps) );
        const tx = valueToX(tval, scale);
        const s = createElem('rect',{x:tx-6,y:axisY-34,width:12,height:6,rx:3,ry:3,fill:'#005f48',opacity:0.9});
        s.setAttribute('transform', `translate(0,0)`);
        svg.appendChild(s);
      }
    }

    // small accessibility titles
    svg.setAttribute('aria-label', `Garis bilangan dari ${min} sampai ${max}. Titik awal: ${a}. Bergerak ${Math.abs(b)} langkah ${b>=0? 'ke kiri':'ke kanan'} ke hasil ${result}.`);
  }

  // update UI and SR
  function updateUI(newState){
    state = computeState(newState.a, newState.b);
    render(state);
    resultText.textContent = `${state.a} - (${state.b}) = ${state.result}`;
    srStatus.textContent = `Nilai awal: ${state.a}. Langkah: ${state.b}. Hasil: ${state.result}.`;
    // small visual pulse for result marker: locate the element and apply class
    // add a tiny delay to ensure element present
    requestAnimationFrame(()=>{
      const res = svg.querySelector('.resultMarker');
      if(res){
        res.classList.remove('pulse');
        void res.offsetWidth;
        res.classList.add('pulse');
        // remove after animation
        setTimeout(()=>res.classList.remove('pulse'),1000);
      }
    });
  }

  // initial render
  function initial(){
    const s = computeState(state.a, state.b);
    state = s;
    render(state);
    resultText.textContent = `${state.a} - (${state.b}) = ${state.result}`;
    srStatus.textContent = `Nilai awal: ${state.a}. Langkah: ${state.b}. Hasil: ${state.result}.`;
  }

  // handle inputs (debounced)
  const onInputChange = debounce(()=> {
    const aVal = Math.round(Number(inputA.value) || 0);
    const bVal = Math.round(Number(inputB.value) || 0);
    updateUI({a:aVal,b:bVal});
  }, 120);

  inputA.addEventListener('input', (e)=>{
    // optional: enforce integer snapping
    if (e.target.value === '' ) return;
    e.target.value = Math.round(Number(e.target.value));
    onInputChange();
  });
  inputB.addEventListener('input', (e)=>{
    if (e.target.value === '' ) return;
    e.target.value = Math.round(Number(e.target.value));
    onInputChange();
  });

  // keyboard accessibility: arrow up/down on focused input changes value by 1
  inputA.addEventListener('keydown', (e)=>{
    if(e.key === 'ArrowUp'){ e.preventDefault(); inputA.value = Number(inputA.value||0)+1; onInputChange(); }
    if(e.key === 'ArrowDown'){ e.preventDefault(); inputA.value = Number(inputA.value||0)-1; onInputChange(); }
  });
  inputB.addEventListener('keydown', (e)=>{
    if(e.key === 'ArrowUp'){ e.preventDefault(); inputB.value = Number(inputB.value||0)+1; onInputChange(); }
    if(e.key === 'ArrowDown'){ e.preventDefault(); inputB.value = Number(inputB.value||0)-1; onInputChange(); }
  });

  // hint button: quick demo examples
  hintBtn.addEventListener('click', ()=>{
    const example = [
      {a:5,b:8},
      {a:5,b:-2},
      {a:-3,b:4},
      {a:2,b:0},
      {a:-6,b:-3}
    ];
    const pick = example[Math.floor(Math.random()*example.length)];
    inputA.value = pick.a; inputB.value = pick.b;
    updateUI({a:pick.a,b:pick.b});
  });

  // initial call
  initial();

  // Resize handler: keep viewBox dims consistent (we use fixed svg viewbox so not needed)
  // But we respect window resize for nicer rendering if you want to recompute anything:
  window.addEventListener('resize', debounce(()=>{
    // re-render with current state to ensure ticks chosen based on new width if you adapt for responsive viewBox
    updateUI({a:state.a,b:state.b});
  }, 200));

  // OPTIONAL: allow dragging markerA to change 'a' (simple implementation)
  // We map mouse x to integer value using current scale
  let dragging = false;
  let activeElem = null;
  svg.addEventListener('pointerdown', (ev) => {
    const pt = ev.target;
    // check if clicked near markerA (circle)
    if (pt.classList.contains('markerA')){
      dragging = true;
      activeElem = 'A';
      svg.setPointerCapture(ev.pointerId);
    }
  });
  svg.addEventListener('pointermove', (ev) => {
    if (!dragging) return;
    // compute scale for current state
    const s = computeScale(state.min, state.max);
    // convert clientX to SVG coordinate (approx using bounding rect)
    const rect = svg.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (svgDims.width / rect.width);
    // compute value and snap to integer
    let val = Math.round( s.min + ( (x - margin.left) / s.pxPerUnit ) );
    // clamp to reasonable bounds
    if (val < s.min) val = Math.round(s.min);
    if (val > s.max) val = Math.round(s.max);
    inputA.value = val;
    updateUI({a:val,b:state.b});
  });
  svg.addEventListener('pointerup', (ev) => {
    if (dragging){
      dragging=false; activeElem=null;
      try{ svg.releasePointerCapture(ev.pointerId); } catch(e){}
    }
  });
  svg.addEventListener('pointerleave', (ev) => {
    if (dragging){ dragging=false; activeElem=null; }
  });

})();
</script>
</body>
</html>
